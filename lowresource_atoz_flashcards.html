<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Alphabet Flashcards – Low Resource</title>
  <meta name="description" content="Ultra‑light, locally hosted alphabet flashcards with sounds and sentences. No frameworks. Keyboard accessible." />
  <style>
    /* ===== Reset and base (no external frameworks; very small CSS) ===== */
    *, *::before, *::after { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; line-height: 1.35; background: #0b1220; color: #e9eef7; }

    /* Layout */
    .wrap { min-height: 100%; display: grid; grid-template-rows: auto 1fr auto; }
    header, footer { padding: .75rem 1rem; background: #0f172a; border-bottom: 1px solid #1e293b; }
    footer { border-top: 1px solid #1e293b; border-bottom: none; }

    header h1 { font-size: clamp(1.1rem, 1.5vw + .9rem, 1.5rem); margin: 0; letter-spacing: .02em; }
    header .sub { opacity: .75; font-size: .9rem; }

    main { display: grid; place-items: center; padding: 1rem; }

    /* Card */
    .card { width: min(820px, 96vw); aspect-ratio: 16 / 10; background: linear-gradient(180deg, #0f172a, #0b1220 40%, #0b1220 60%, #0f172a);
            border: 1px solid #1e293b; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,.35); padding: 1rem; display: grid; grid-template-rows: auto 1fr auto; gap: .75rem; }

    .deckbar { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
    .deckbar label { font-size: .9rem; opacity: .85; }
    .mode-tabs { display: inline-flex; gap: .25rem; padding: .25rem; background: #0b1328; border: 1px solid #1e293b; border-radius: 999px; }
    .mode-btn { appearance: none; border: 0; background: transparent; color: #cfd8ea; padding: .35rem .7rem; border-radius: 999px; cursor: pointer; font-size: .9rem; }
    .mode-btn[aria-pressed="true"] { background: #1e293b; color: #fff; }

    /* Flash area */
    .flash { display: grid; grid-template-rows: 1fr auto; gap: .5rem; height: 100%; }
    .glyph { display: grid; place-items: center; text-align: center; padding: .5rem; }
    .glyph .big { font-weight: 800; font-size: clamp(5rem, 18vw, 11rem); line-height: 1; letter-spacing: .02em; }
    .glyph .mini { font-size: clamp(1rem, 3.5vw, 1.4rem); opacity: .85; margin-top: .25rem; }

    .speech { display: flex; justify-content: center; gap: .5rem; flex-wrap: wrap; }
    .btn { appearance: none; border: 1px solid #1e293b; background: #0b1328; color: #e9eef7; padding: .6rem .9rem; border-radius: 12px; cursor: pointer; font-size: 1rem; }
    .btn:hover { background: #14203d; }
    .btn:active { transform: translateY(1px); }

    /* Controls */
    .controls { display: grid; grid-template-columns: 1fr auto 1fr; gap: .5rem; align-items: center; }
    .nav { display: flex; gap: .5rem; justify-content: flex-start; }
    .jump { display: flex; gap: .5rem; justify-content: flex-end; }

    .icon { width: 1.1em; height: 1.1em; vertical-align: -0.2em; }

    /* Progress */
    .progress { text-align: center; font-size: .95rem; opacity: .8; }

    /* A11y utility */
    .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: no-preference) {
      .card { transition: transform .2s ease, box-shadow .2s ease; }
      .card:focus-within { outline: none; box-shadow: 0 12px 38px rgba(0,0,0,.45); transform: translateY(-2px); }
    }

    /* Small screens */
    @media (max-width: 480px) {
      .controls { grid-template-columns: 1fr; }
      .nav, .jump { justify-content: center; }
    }
  </style>
</head>
<body>
    
    <h2><a href="https://chatgpt.com/share/68dbd7f4-4b08-800c-91be-2d1cd00c84d2" target="_blank">ChatGPT Link</a></h2>
<div class="wrap">
  <header>
    <h1>Alphabet Flashcards <span class="sub">(offline, minimal memory, no frameworks)</span></h1>
  </header>

  <main>
    <section class="card" role="region" aria-label="Flashcard">
      <div class="deckbar">
        <label for="deckSel">Deck:</label>
        <select id="deckSel" aria-label="Choose deck">
          <option value="letters">Letters (A–Z)</option>
          <option value="phonics">Phonics (A–Z)</option>
          <option value="sentences">Sentences (A–Z)</option>
        </select>

        <div class="mode-tabs" role="tablist" aria-label="Display mode">
          <button class="mode-btn" data-mode="letter" aria-pressed="true" role="tab" aria-selected="true">Letter</button>
          <button class="mode-btn" data-mode="sound" aria-pressed="false" role="tab" aria-selected="false">Sound</button>
          <button class="mode-btn" data-mode="sentence" aria-pressed="false" role="tab" aria-selected="false">Sentence</button>
        </div>
      </div>

      <div class="flash">
        <div class="glyph" id="glyph" tabindex="0" aria-live="polite" aria-atomic="true">
          <div class="big" id="big">A</div>
          <div class="mini" id="mini">/æ/ — Apple</div>
        </div>
        <div class="speech">
          <button class="btn" id="speakLetter" aria-label="Speak letter (space)">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M3 9v6h4l5 5V4L7 9H3zm13.5 3a4.5 4.5 0 0 0-2.5-4v8a4.5 4.5 0 0 0 2.5-4zm-2.5-7.8v2.1a7.5 7.5 0 0 1 0 15.4v2.1c5.4-1 9.5-5.8 9.5-9.8s-4.1-8.8-9.5-9.8z"/></svg>
            Letter
          </button>
          <button class="btn" id="speakWord" aria-label="Speak word">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M2 12a10 10 0 1 0 20 0A10 10 0 0 0 2 12zm11-5v10l-6-5 6-5z"/></svg>
            Word
          </button>
          <button class="btn" id="speakSentence" aria-label="Speak sentence">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M21 6H3v12h18V6zM5 8h14v8H5V8zm2 2h6v2H7v-2z"/></svg>
            Sentence
          </button>
        </div>
      </div>

      <div class="controls">
        <div class="nav">
          <button class="btn" id="prev" aria-label="Previous (Left Arrow)">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M15.41 7.41 14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
            Prev
          </button>
          <button class="btn" id="next" aria-label="Next (Right Arrow)">
            Next
            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M8.59 16.59 10 18l6-6-6-6-1.41 1.41L13.17 12z"/></svg>
          </button>
        </div>
        <div class="progress" id="progress" aria-live="polite">1 / 26</div>
        <div class="jump">
          <label for="jumpSel" class="visually-hidden">Jump to letter</label>
          <select id="jumpSel" aria-label="Jump to any card"></select>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <small>
      Keyboard: Left/Right to move, Up/Down to change mode, Space to speak. This works without internet. Audio uses Web Speech if available. You may replace with small .mp3 files if preferred.
      <span id="selftest" style="display:block;margin-top:.35rem;opacity:.75"></span>
    </small>
  </footer>
</div>

<script>
  // ===== Data model (tiny, in-memory). Replace or extend with external JSON to scale. =====
  // A minimal alphabet with a sample word and sentence each. Keep memory usage very low.
  const A_TO_Z = Array.from({ length: 26 }, (_, i) => String.fromCharCode(65 + i));

  // Base decks. Each entry keeps fields that the modes can selectively display.
  // FIX: use sampleSentenceFor instead of missing defaultSentenceFor.
  const decks = {
    letters: A_TO_Z.map(ch => ({
      letter: ch,
      word: defaultWordFor(ch),
      sound: phonemeFor(ch),
      sentence: sampleSentenceFor(ch)
    })),
    phonics: A_TO_Z.map(ch => ({
      letter: ch,
      word: defaultWordFor(ch),
      sound: phonemeFor(ch),
      sentence: `${ch} as in ${defaultWordFor(ch)}.`
    })),
    sentences: A_TO_Z.map(ch => ({
      letter: ch,
      word: defaultWordFor(ch),
      sound: phonemeFor(ch),
      sentence: sampleSentenceFor(ch)
    }))
  };

  function defaultWordFor(ch) {
    // Very small mapping to remain lightweight. You may expand freely.
    const map = {
      A: "Apple", B: "Ball", C: "Cat", D: "Dog", E: "Egg", F: "Fish", G: "Goat",
      H: "Hat", I: "Ink", J: "Jam", K: "Kite", L: "Leaf", M: "Moon",
      N: "Nest", O: "Orange", P: "Pen", Q: "Queen", R: "Rain", S: "Sun",
      T: "Tree", U: "Umbrella", V: "Van", W: "Water", X: "Box", Y: "Yarn", Z: "Zebra"
    };
    return map[ch] || ch;
  }

  function phonemeFor(ch) {
    const map = {
      A: "/æ/", B: "/b/", C: "/k/", D: "/d/", E: "/ɛ/", F: "/f/", G: "/g/",
      H: "/h/", I: "/ɪ/", J: "/dʒ/", K: "/k/", L: "/l/", M: "/m/",
      N: "/n/", O: "/ɒ/", P: "/p/", Q: "/k/", R: "/ɹ/", S: "/s/",
      T: "/t/", U: "/ʌ/", V: "/v/", W: "/w/", X: "/ks/", Y: "/j/", Z: "/z/"
    };
    return map[ch] || "/" + ch.toLowerCase() + "/";
  }

  function sampleSentenceFor(ch) {
    const word = defaultWordFor(ch);
    return `${word} begins with ${ch}.`;
  }

  // ===== DOM refs =====
  const deckSel = document.getElementById('deckSel');
  const glyph = document.getElementById('glyph');
  const big = document.getElementById('big');
  const mini = document.getElementById('mini');
  const speakLetterBtn = document.getElementById('speakLetter');
  const speakWordBtn = document.getElementById('speakWord');
  const speakSentenceBtn = document.getElementById('speakSentence');
  const prevBtn = document.getElementById('prev');
  const nextBtn = document.getElementById('next');
  const progressEl = document.getElementById('progress');
  const jumpSel = document.getElementById('jumpSel');
  const modeBtns = Array.from(document.querySelectorAll('.mode-btn'));

  // ===== State (tiny) =====
  let state = {
    deckKey: 'letters',
    index: 0,
    mode: 'letter' // 'letter' | 'sound' | 'sentence'
  };

  // Populate jump menu once
  function buildJumpMenu() {
    jumpSel.innerHTML = '';
    A_TO_Z.forEach((ch, i) => {
      const o = document.createElement('option');
      o.value = String(i);
      o.textContent = `${i + 1}. ${ch}`;
      jumpSel.appendChild(o);
    });
  }
  buildJumpMenu();

  // Render the current card based on state
  function render() {
    const deck = decks[state.deckKey];
    const total = deck.length;
    const item = deck[state.index];

    // Update mode tab aria pressed
    for (const b of modeBtns) {
      const pressed = b.dataset.mode === state.mode;
      b.setAttribute('aria-pressed', String(pressed));
      b.setAttribute('aria-selected', String(pressed));
    }

    // Big glyph content
    big.textContent = item.letter;

    // Mini line depends on mode
    if (state.mode === 'letter') {
      mini.textContent = `${item.sound} — ${item.word}`;
    } else if (state.mode === 'sound') {
      mini.textContent = `${item.sound} — ${item.word}`;
    } else {
      mini.textContent = item.sentence;
    }

    progressEl.textContent = `${state.index + 1} / ${total}`;
    jumpSel.value = String(state.index);

    // Announce for screen readers
    glyph.setAttribute('aria-label', `${item.letter}. ${mini.textContent}`);
  }

  // Navigation helpers
  function clampIndex(i) {
    const deck = decks[state.deckKey];
    if (i < 0) return 0;
    if (i >= deck.length) return deck.length - 1;
    return i;
  }
  function next() { state.index = clampIndex(state.index + 1); render(); }
  function prev() { state.index = clampIndex(state.index - 1); render(); }

  // Speech helpers (Web Speech API). If unavailable, no failure is thrown.
  function speak(text) {
    try {
      if (!('speechSynthesis' in window)) return; // Respect devices without TTS
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 0.95; u.pitch = 1.0; u.volume = 1.0;
      window.speechSynthesis.speak(u);
    } catch (_) { /* no-op */ }
  }

  function speakCurrent(kind) {
    const item = decks[state.deckKey][state.index];
    if (kind === 'letter') speak(item.letter);
    else if (kind === 'word') speak(item.word);
    else speak(item.sentence);
  }

  // Event wiring
  deckSel.addEventListener('change', () => { state.deckKey = deckSel.value; state.index = 0; render(); });
  jumpSel.addEventListener('change', () => { state.index = Number(jumpSel.value); render(); });

  speakLetterBtn.addEventListener('click', () => speakCurrent('letter'));
  speakWordBtn.addEventListener('click', () => speakCurrent('word'));
  speakSentenceBtn.addEventListener('click', () => speakCurrent('sentence'));

  prevBtn.addEventListener('click', prev);
  nextBtn.addEventListener('click', next);

  for (const b of modeBtns) {
    b.addEventListener('click', () => { state.mode = b.dataset.mode; render(); });
  }

  // Keyboard: arrows to navigate, Up/Down to cycle mode, Space to speak letter
  window.addEventListener('keydown', (e) => {
    switch (e.key) {
      case 'ArrowRight': next(); e.preventDefault(); break;
      case 'ArrowLeft': prev(); e.preventDefault(); break;
      case 'ArrowUp': cycleMode(-1); e.preventDefault(); break;
      case 'ArrowDown': cycleMode(1); e.preventDefault(); break;
      case ' ': // space
        speakCurrent('letter');
        e.preventDefault();
        break;
    }
  });

  function cycleMode(dir) {
    const order = ['letter', 'sound', 'sentence'];
    let idx = order.indexOf(state.mode);
    idx = (idx + dir + order.length) % order.length;
    state.mode = order[idx];
    render();
  }

  // Initial paint
  render();

  // ===== Tiny self-test harness (runs once, logs to console and footer) =====
  (function runSelfTests(){
    const results = [];
    function assert(name, cond) { results.push({ name, pass: !!cond }); }
    function eq(name, a, b) { assert(name, a === b); }

    try {
      eq('A_TO_Z length == 26', A_TO_Z.length, 26);
      eq('letters deck size', decks.letters.length, 26);
      eq('phonics deck size', decks.phonics.length, 26);
      eq('sentences deck size', decks.sentences.length, 26);
      eq('first letter A', decks.letters[0].letter, 'A');
      eq('last letter Z', decks.letters[25].letter, 'Z');
      eq('sampleSentenceFor(A)', sampleSentenceFor('A'), 'Apple begins with A.');
      eq('phoneme X', phonemeFor('X'), '/ks/');
      eq('phoneme Z', phonemeFor('Z'), '/z/');
      eq('initial progress text', progressEl.textContent.trim(), '1 / 26');
    } catch (e) {
      results.push({ name: 'harness error', pass: false, error: e.message });
    }

    const passCount = results.filter(r => r.pass).length;
    const out = `Self‑check: ${passCount}/${results.length} passed`;
    console.log(out, results);
    const st = document.getElementById('selftest');
    if (st) st.textContent = out;
  })();

  // ===== Optional: load external deck JSON on demand (keeps memory low) =====
  // Example: place a file at ./decks/animals.json with the same shape as decks.letters entries.
  // You can call loadExternalDeck('myAnimals', './decks/animals.json') and it will appear in the selector.
  async function loadExternalDeck(key, url) {
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error('Failed: ' + res.status);
      const items = await res.json(); // [{letter, word, sound, sentence}, ...]
      if (!Array.isArray(items) || !items.length) throw new Error('Bad deck data');
      decks[key] = items;
      const opt = document.createElement('option');
      opt.value = key; opt.textContent = key.charAt(0).toUpperCase() + key.slice(1);
      deckSel.appendChild(opt);
    } catch (err) {
      console.warn('Deck load skipped:', err.message);
    }
  }
  // Example usage (commented out):
  // loadExternalDeck('animals', './decks/animals.json');
</script>

</body>
</html>
